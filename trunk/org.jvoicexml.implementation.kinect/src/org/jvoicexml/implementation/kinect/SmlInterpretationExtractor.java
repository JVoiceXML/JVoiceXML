/*
 * File:    $HeadURL$
 * Version: $LastChangedRevision$
 * Date:    $Date$
 * Author:  $LastChangedBy$
 *
 * JVoiceXML - A free VoiceXML implementation.
 *
 * Copyright (C) 2012 JVoiceXML group - http://jvoicexml.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package org.jvoicexml.implementation.kinect;

import java.util.List;
import java.util.Stack;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;

/**
 * Content handler to extract the SML interpretation from SML string.
 * <p>
 * SML stands for SAPI Semantic markup language which is the XML document
 * returned by SAPI 6.0 when an
 * utterance is determined to be in-grammar. (SAPI SML is a SAPI-specific return
 * format. SALT interpreters are agnostic to the actual content format of the
 * returned document, provided it is an XML document).
 * SAPI SML contains semantic values, confidence scores and the words used by
 * the speaker. (It is generated by script or XSLT instructions contained within
 * the grammar rules.)
 * </p>
 * @author Dirk Schnelle-Walka
 * @version $Revision$
 * @since 0.7.6
 *
 */
final class SmlInterpretationExtractor implements ContentHandler {
    /** Intermediately read string between two tags. */
    private StringBuilder str;

    /** Intermediately read string between the SML tags. */
    private StringBuilder strTag;

    /** The current tag prefix. */
    private Stack<String> tagprefixes;

    /** Collected semantic interpretations. */
    private List<SmlInterpretation> interpretations;

    /** The utterance. */
    private String utterance;

    /** The tag for the utterance. */
    private String utteranceTag;

    /** Confidence in the utterance. */
    private float confidence;

    /**
     * {@inheritDoc}
     */
    @Override
    public void setDocumentLocator(final Locator locator) {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void startDocument() throws SAXException {
        interpretations = new java.util.ArrayList<SmlInterpretation>();
        tagprefixes = new java.util.Stack<String>();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void endDocument() throws SAXException {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void startPrefixMapping(final String prefix, final  String uri)
            throws SAXException {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void endPrefixMapping(final String prefix) throws SAXException {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void startElement(final String uri, final String localName,
            final String qName, final Attributes atts) throws SAXException {
        if (localName.equalsIgnoreCase("SML")) {
            utterance = atts.getValue("text");
            final String conf = atts.getValue("confidence");
            if (conf != null) {
                confidence = Float.parseFloat(conf);
            }
            strTag = new StringBuilder();
        } else {
            final StringBuilder tag = new StringBuilder();
            for (int i = 0; i < tagprefixes.size(); i++) {
                final String tagprefix = tagprefixes.get(i);
                if (i != 0) {
                    tag.append('.');
                }
                tag.append(tagprefix);
            }
            if (tag.length() != 0) {
                tag.append('.');
            }
            tag.append(localName);
            tagprefixes.push(localName);
            final String conf = atts.getValue("confidence");
            float fconf = 0.0f;
            if (conf != null) {
                fconf = Float.parseFloat(conf);
            }
            SmlInterpretation interpretation =
                    new SmlInterpretation(tag.toString(), fconf);
            interpretations.add(interpretation);
            str = new StringBuilder();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void endElement(final String uri, final String localName,
            final String qName)
            throws SAXException {
        if (localName.equalsIgnoreCase("SML")) {
            utteranceTag = strTag.toString().trim();
            strTag = null;
        } else  if (str != null) {
            final SmlInterpretation interpretation =
                    findInterpretation(localName);
            if (interpretation != null) {
                interpretation.setValue(str.toString());
            }
            str = null;
        }
        if (!tagprefixes.isEmpty()) {
            tagprefixes.pop();
        }
    }

    /**
     * Finds the interpretation with the given local name.
     * @param localName the local name to look for
     * @return found interpretation 
     */
    private SmlInterpretation findInterpretation(final String localName) {
        final String prefixedName = "." + localName;
        for (int i = interpretations.size() - 1; i >= 0; i--) {
            final SmlInterpretation interpretation = interpretations.get(i);
            final String tag = interpretation.getTag();
            if (tag.endsWith(prefixedName) || tag.equals(localName)) {
                return interpretation;
            }
        }
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void characters(final char[] ch, final int start, final int length)
            throws SAXException {
        if (str != null) {
            str.append(ch, start, length);
        } else if (strTag != null) {
            strTag.append(ch, start, length);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void ignorableWhitespace(final char[] ch, final int start,
            final int length) throws SAXException {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void processingInstruction(final String target, final String data)
            throws SAXException {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void skippedEntity(final String name) throws SAXException {
    }

    /**
     * Retrieves the utterance.
     * @return the utterance
     */
    public String getUtterance() {
        return utterance;
    }

    /**
     * Retrieves the tag for the utterance.
     * @return tag for the utterance
     */
    public String getUtteranceTag() {
        return utteranceTag;
    }

    /**
     * Retrieves the confidence.
     * @return the confidence
     */
    public float getConfidence() {
        return confidence;
    }

    /**
     * Retrieves all interpretations.
     * @return all interpretations
     */
    public List<SmlInterpretation> getInterpretations() {
        return interpretations;
    }
}
